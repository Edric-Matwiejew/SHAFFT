@defgroup fortran_interfaces Fortran Generic Interfaces
@ingroup fortran_api
@brief Generic interfaces that dispatch to precision-specific subroutines.

These generic interfaces allow calling SHAFFT routines without specifying
the precision suffix. The compiler selects the appropriate implementation
based on argument types.

Subroutines return a SHAFFT status code via a required @c ierr argument.
Caller code is responsible for handling errors; no fail-fast behavior is
applied by the wrappers.

@section plan_interface shafftPlan

Create an FFT plan. Dispatches to:
- shafftPlanNDA() - Use when number of distributed axes is known
- shafftPlanCart() - Use when Cartesian decomposition dimensions are known

@section buffer_interfaces Buffer Management Interfaces

@subsection setbuffers shafftSetBuffers

Attach data and work buffers to a plan. Dispatches to:
- shafftSetBuffers_sp() - Single-precision complex
- shafftSetBuffers_dp() - Double-precision complex

The caller is responsible for allocation and lifetime of the buffers.
Buffers must remain valid until the plan is destroyed or new buffers
are attached. Internally, SHAFFT may swap the roles of data/work during
execution, so use shafftGetBuffers() to determine which holds results
after shafftExecute().

@subsection getbuffers shafftGetBuffers

Retrieve the plan's current data/work buffer pointers. Dispatches to:
- shafftGetBuffers_sp() - Single-precision complex
- shafftGetBuffers_dp() - Double-precision complex

@warning Buffers may be swapped internally during execution. Call this
routine <b>after</b> shafftExecute() to ensure that @c data points to the
transformed results.

@note @c alloc_size is now optional. If omitted, the wrapper calls
@c shafftGetAllocSize internally to set the pointer extents.

@subsection allocbuffer shafftAllocBuffer

Allocate a buffer suitable for the current backend. Dispatches to:
- shafftAllocBuffer_sp() - Single-precision complex
- shafftAllocBuffer_dp() - Double-precision complex

Allocates device memory on GPU backends (hipFFT), host-aligned memory on
CPU backends (FFTW). Use shafftFreeBuffer() to release.

@subsection freebuffer shafftFreeBuffer

Free a buffer allocated with shafftAllocBuffer(). Dispatches to:
- shafftFreeBuffer_sp() - Single-precision complex
- shafftFreeBuffer_dp() - Double-precision complex

The buffer pointer is nullified after freeing.

@subsection copytobuffer shafftCopyToBuffer

Copy data from host memory to a SHAFFT buffer. Dispatches to:
- shafftCopyToBuffer_sp() - Single-precision complex
- shafftCopyToBuffer_dp() - Double-precision complex

On GPU backends (hipFFT), performs host-to-device copy.
On CPU backends (FFTW), performs memcpy.

The `count` argument is optional; if omitted, the entire source array is copied.

@subsection copyfrombuffer shafftCopyFromBuffer

Copy data from a SHAFFT buffer to host memory. Dispatches to:
- shafftCopyFromBuffer_sp() - Single-precision complex
- shafftCopyFromBuffer_dp() - Double-precision complex

On GPU backends (hipFFT), performs device-to-host copy.
On CPU backends (FFTW), performs memcpy.

The `count` argument is optional; if omitted, the destination array extent is used.

@note All Fortran wrappers return status via the required @c ierr argument.

@par Example Usage:
@code{.f90}
use shafft

complex(c_float_complex), pointer :: data_buf(:), work_buf(:)
integer :: ierr

! Allocate buffers (generic interface selects precision from pointer type)
call shafftAllocBuffer(alloc_size, data_buf, ierr)
call shafftAllocBuffer(alloc_size, work_buf, ierr)

! Attach to plan
call shafftSetBuffers(plan, data_buf, work_buf, ierr)

! After execute, retrieve current buffer state
call shafftGetBuffers(plan, alloc_size, data_buf, work_buf, ierr)
@endcode
